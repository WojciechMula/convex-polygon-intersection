<?xml version="1.0" ?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">

<svg height="800px" width="800px" xmlns="http://www.w3.org/2000/svg" id="canvas">
	<title>Convex polygons intersection (demo by Wojciech Mu≈Ça)</title>

	<polygon id="polygon0"
		points=""
		fill="none"
		stroke="black"
	/>

	<polygon id="polygon1"
		points=""
		fill="none"
		stroke="black"
	/>

    <line id="sample_line"
        x1="0"
        y1="0"
        x2="100"
        y2="100"
        stroke="red"
        stroke-width="0px"
    />
	
	<text id="status"
		x="5"
		y="30"
	></text>

<script type="text/javascript">
<![CDATA[

var polygons = [];

function create_convex_polygon(num_points, radius, dx, dy) {

    function random(min, max) {
        return Math.random() * (max - min) + min;
    }

    function randint(min, max) {
        return Math.floor(Math.random() * (max - min) + min);
    }

    function get_length(x, y) {
        return Math.sqrt(x*x + y*y);
    }

    function set_length(x, y, length) {
        var len = get_length(x, y);

        return [x*length/len, y*length/len];
    }

    var points = [
        set_length(random(-radius, radius), random(-radius, radius), radius),
        set_length(random(-radius, radius), random(-radius, radius), radius),
        set_length(random(-radius, radius), random(-radius, radius), radius)
    ];

    var [cx, cy] = get_center(points);

    translate(points, -cx, -cy);

    while (points.length < num_points) {
        var idx = randint(0, points.length);
        var p1 = points[idx];
        var p2 = points[idx + 1];

        if (p2 == undefined) {
            continue;
        }

        var x = (p1[0] + p2[0])/2;
        var y = (p1[1] + p2[1])/2;
        var min_length = get_length(x, y);

        var p = set_length(x, y, random(min_length, radius));

        points.splice(idx+1, 0, p);
    }

    return translate(points, dx, dy);
}

function translate(points, dx, dy) {
    for (i in points) {
        points[i][0] += dx;
        points[i][1] += dy;
    }

    return points;
}

function rotate(points, x0, y0, angle) {
    var c = Math.cos(angle);
    var s = Math.sin(angle);

    for (i in points) {
        var x = points[i][0] - x0;
        var y = points[i][1] - y0;

        points[i][0] = x*c - y*s + x0;
        points[i][1] = x*s + y*c + y0;
    }

    return points;
}

function get_center(points) {
    var x = 0;
    var y = 0;
    for (i in points) {
        x += points[i][0];
        y += points[i][1];
    }

    return [x/points.length, y/points.length];
}

function display_polygon(points, id) {
    var item = document.getElementById(id);
    var tmp = [];

    for (i in points) {
        tmp.push(points[i][0]);
        tmp.push(points[i][1]);
    }

    item.setAttribute("points", tmp.join(" "));
}

var moving = {
    object_id:  null,
    origin_x:   null,
    origin_y:   null,
    current_x:  0,
    current_y:  0,
    selected_id: 1,
}

function onMouseClick(ev) {
    if (moving.object_id == null) {
        moving.object_id = moving.selected_id;
        moving.origin_x = ev.clientX;
        moving.origin_y = ev.clientY;
    } else {
        moving.object_id = null;
    }
}

function onMouseMove(ev) {
    moving.current_x = ev.clientX;
    moving.current_y = ev.clientY;
    if (moving.object_id !== null) {
        var dx = moving.origin_x - ev.clientX;
        var dy = moving.origin_y - ev.clientY;

        moving.origin_x = ev.clientX;
        moving.origin_y = ev.clientY;
        
        var idx = moving.object_id;
        polygons[idx] = translate(polygons[idx], -dx, -dy);
        display_polygon(polygons[idx], "polygon" + idx);
        check(polygons[0], polygons[1]);
    }
}

function rotateSelected(angle) {
    var idx = moving.selected_id;

    var [cx, cy] = get_center(polygons[idx]);

    rotate(polygons[idx], cx, cy, angle * (Math.PI / 180));
    display_polygon(polygons[idx], "polygon" + idx);
    check(polygons[0], polygons[1]);
}

function onKeyPress(ev) {
    var key = null;
    try {
        key = String.fromCharCode(ev.charCode);
    } catch (e) {
        null;
    };

    switch (key) {
        case '1':
            moving.selected_id = 0
            break;
        case '2':
            moving.selected_id = 1
            break;
        case 'r':
            rotateSelected(+1.0);
            break;
        case 'R':
            rotateSelected(-1.0);
            break;
    }
}

function init() {
    polygons.push(create_convex_polygon( 5, 100, 100, 200));
    polygons.push(create_convex_polygon( 5, 100, 300, 200));

    for (i in polygons) {
        display_polygon(polygons[i], "polygon" + i);
    }

    var canvas = document.getElementById("canvas")
    canvas.onclick = onMouseClick;
    canvas.onmousemove = onMouseMove;
    canvas.onkeypress = onKeyPress;
}

function check(polygon1, polygon2) {
    var line = document.getElementById("sample_line");
    line.setAttribute('stroke-width', '0px');

    for (i in polygon1) {
        var [A1, A2, A3] = get_3points(polygon1, i);

        for (j in polygon2) {
            var [B1, B2, B3] = get_3points(polygon2, j);
            var [a, b, c] = get_line_equation(A2, B2);

            var sideA = get_side(A1, A3, a, b, c);   
            var sideB = get_side(B1, B3, a, b, c);   

            if (sideA != null && sideB != null) {
                if (sideA * sideB < 0.0) {
                    line.setAttribute('x1', A2[0]);
                    line.setAttribute('y1', A2[1]);
                    line.setAttribute('x2', B2[0]);
                    line.setAttribute('y2', B2[1]);
                    line.setAttribute('stroke-width', '1px');
                    return;
                }
            }
        }
    }
}

// return [points[index-1], points[index], points[index+1]], taking care
// about wrapping around
function get_3points(points, index) {
    var idx = 1 * index;
    var idx1 = idx - 1;
    var idx2 = idx;
    var idx3 = idx + 1;

    if (idx1 < 0) {
        idx1 = points.length - 1;
    }

    if (idx3 == points.length) {
        idx3 = 0;
    }

    return [
        points[idx1],
        points[idx2],
        points[idx3],
    ];
}

function get_side(point1, point2, a, b, c) {
    var s1 = get_line_side(point1[0], point1[1], a, b, c);
    var s2 = get_line_side(point2[0], point2[1], a, b, c);
    var side = s1 * s2;

    if (side < 0.0) {
        return null;
    } else if (side > 0.0) {
        return s1;
    }

    if (s1 == 0.0) {
        return s2;
    }

    if (s2 == 0.0) {
        return s1;
    }
}

function get_line_side(x, y, a, b, c) {
    return sign(a*x + b*y + c);
}

function sign(x) {
    if (x < 0.0)
        return -1;

    if (x > 0.0)
        return +1;

    return 0.0;
}

function get_line_equation(p1, p2) {
    var x1 = p1[0];
    var y1 = p1[1];

    var x2 = p2[0];
    var y2 = p2[1];

    var a = y2 - y1;
    var b = -(x2 - x1);
    var c = -(a*x1 + b*y1);

    return [a, b, c];
}

init();
	

// ]]>
	</script>
	</svg>
<!--
	vim: ts=4 sw=4 nowrap ft=javascript
-->
